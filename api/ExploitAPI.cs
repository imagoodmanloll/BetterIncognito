using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SkidAPI
{
    internal class Pipe
    {
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr CreateFile(string lpFileName, uint dwDesiredAccess, uint dwShareMode, IntPtr lpSecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool CloseHandle(IntPtr hObject);

        private const uint GENERIC_READ = 0x80000000;
        private const uint GENERIC_WRITE = 0x40000000;
        private const uint OPEN_EXISTING = 3;
        private const int INVALID_HANDLE_VALUE = -1;

        public static bool NamedPipeExists(string pipe)
        {
            IntPtr handle = CreateFile(
                pipe,
                GENERIC_READ | GENERIC_WRITE,
                0,
                IntPtr.Zero,
                OPEN_EXISTING,
                0,
                IntPtr.Zero);

            if (handle.ToInt64() != INVALID_HANDLE_VALUE)
            {
                CloseHandle(handle);
                return true;
            }
            return false;
        }

        public static void NamedPipeSendData(string bytecode)
        {
            try
            {
                using (NamedPipeClientStream pipeclient = new NamedPipeClientStream(".", "BetterIncongitoPipe", PipeDirection.Out))
                {
                    pipeclient.Connect();

                    using (StreamWriter writer = new StreamWriter(pipeclient))
                    {
                        writer.AutoFlush = true;
                        writer.WriteLine(bytecode);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Exception while executing! " + ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                Environment.Exit(-1);
            }
        }

        public string name = @"\\.\pipe\BetterIncongitoPipe";
    }

    public class SkidAPI
    {
        public static string Exploit = "SkidAPI";

        [StructLayout(LayoutKind.Sequential)]
        public struct STARTUPINFO
        {
            public uint cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public uint dwX;
            public uint dwY;
            public uint dwXSize;
            public uint dwYSize;
            public uint dwXCountChars;
            public uint dwYCountChars;
            public uint dwFillAttribute;
            public uint dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public uint dwProcessId;
            public uint dwThreadId;
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool CreateProcess(
            string lpApplicationName,
            string lpCommandLine,
            IntPtr lpProcessAttributes,
            IntPtr lpThreadAttributes,
            bool bInheritHandles,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);

        static bool IsProcessRunning(string processName) => Process.GetProcessesByName(processName).Length > 0;

        static void CloseProcess(string processName)
        {
            foreach (Process process in Process.GetProcessesByName(processName))
            {
                try { process.Kill(); } catch { }
            }
        }

        static async void NOTRACIST()
        {
            while (true)
            {
                if (!IsProcessRunning("RobloxPlayerBeta"))
                    CloseProcess("main");
                await Task.Delay(1000);
            }
        }

        public void Attach()
        {
            NOTRACIST();

            if (!File.Exists("main.exe"))
            {
                MessageBox.Show("Could not find main.exe\nDid you turn off antivirus?\n\nIf you are this exploit's developer, call Update(); somewhere in your code", Exploit + " Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (!IsRobloxOpen())
            {
                MessageBox.Show("Roblox isn't open", Exploit + " Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            STARTUPINFO si = new STARTUPINFO { cb = (uint)Marshal.SizeOf(typeof(STARTUPINFO)) };
            if (CreateProcess(null, "main.exe", IntPtr.Zero, IntPtr.Zero, false, 0, IntPtr.Zero, null, ref si, out _))
            {
                MessageBox.Show("Attach successful", Exploit + " Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                MessageBox.Show("Exception caught for lacking! " + Marshal.GetLastWin32Error(), Exploit + " Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
        }

        public void Execute(string source)
        {
            if (File.Exists("main.exe"))
            {
                if (Pipe.NamedPipeExists(@"\\.\pipe\BetterIncongitoPipe"))
                {
                    Pipe.NamedPipeSendData(source);
                }
                else
                {
                    MessageBox.Show("Attach to execute scripts", Exploit + " Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            }
            else
            {
                MessageBox.Show("Could not find main.exe\nScript failed to execute", Exploit + " Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        public void Update()
        {
            using WebClient server = new WebClient();
            if (File.Exists("main.exe"))
            {
                File.Delete("main.exe");
                server.DownloadFile(server.DownloadString("https://github.com/FlexXero/betterincongitostuff/raw/refs/heads/main/betterincog.link"), "main.exe");
                string ver = server.DownloadString("https://github.com/FlexXero/betterincongitostuff/raw/refs/heads/main/version.doc");
                MessageBox.Show("Updated the API to version " + ver, Exploit + " Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                server.DownloadFile(server.DownloadString("https://github.com/FlexXero/betterincongitostuff/raw/refs/heads/main/betterincog.link"), "main.exe");
            }
        }

        public bool IsRobloxOpen() => Process.GetProcessesByName("RobloxPlayerBeta").Length > 0;
    }
}
