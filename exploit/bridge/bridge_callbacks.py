from exploit.funcs.base import Window
from exploit.funcs.instance import Instance
from exploit.bridge.bridge import Bridge as RBXBridge
from exploit.funcs.bytecode import Bytecode as RBXBytecode
from exploit.funcs.utils import Capabilities
import psutil, shutil, re, os, win32clipboard, ctypes, aiohttp, asyncio # type: ignore
import requests
import subprocess

user32 = ctypes.windll.user32
base_script = ["LocalScript", "ModuleScript"]

def path_no_escape(f_path: str):
    current_dir = os.getcwd()
    image_path = os.path.join(current_dir, "workspace", *f_path.split("\\"))

    return image_path.replace("..", "")

def get_formulated_filename(file_name: str) -> str:
    pass

def register_callbacks(Bridge: RBXBridge):
    global BridgeService
    BridgeService = Bridge

    @BridgeService.RegisterCallback
    def get_rawmetatable(session:int, args: list[any]):
        # real ðŸ¤¥
        pass

    @BridgeService.RegisterCallback
    def spoof_instance(session: int, args: list[any]):
        spoofing = args[0]
        new_instance = args[1]

        if (
            type(spoofing) == Instance
            and (type(new_instance) == Instance
            or type(new_instance) == int)
        ):
            spoofing.Spoof(new_instance)

    @BridgeService.RegisterCallback
    def get_instance_address(session: int, args: list[any]):
        target_instance = args[0]

        if type(target_instance) == Instance:
            return [target_instance.Address]

    @BridgeService.RegisterCallback
    def set_clipboard(session: int, args: list[any]):
        success = False

        if isinstance(args[0], str):
            win32clipboard.OpenClipboard()

            try:
                win32clipboard.EmptyClipboard()
                win32clipboard.SetClipboardData(win32clipboard.CF_UNICODETEXT, args[0])
                success = True

            finally:
                win32clipboard.CloseClipboard()

        else:
            return False

        return [success]

    @BridgeService.RegisterCallback
    def set_scriptable(session: int, args: list[any]):
        if (
            isinstance(args[0], Instance)
            and type(args[1]) == str
            and type(args[2]) == bool
        ):
            PropDescriptor = args[0].ClassDescriptor.PropertyDescriptors.Get(args[1])

            if PropDescriptor.Address < 1000:
                return [False]

            PropDescriptor.SetScriptable(args[2])
            return [True]

    @BridgeService.RegisterCallback
    def load_source(session: int, args: list[any]):
        if isinstance(args[0], Instance) and type(args[1]) == str:
            args[0].SetModuleBypass()
            args[0].Bytecode = RBXBytecode.Compile(
                f"return function(...) {args[1]} \nend", f"load-{session}.btc"
            )

            # TODO: return if compile success
            return [True]

    @BridgeService.RegisterCallback
    def reset_module_bytecode(session: int, args: list[any]):
        if isinstance(args[0], Instance):
            args[0].ResetModule()

    @BridgeService.RegisterCallback
    def get_hwid(session: int, args: list[any]):
        try:
            hwid = subprocess.check_output('wmic csproduct get uuid').decode().split('\n')[1].strip()
            return [True, hwid]
        except Exception as e:
            print(f"BRIDGE ERROR: Failed to get HWID: {e}")
            return [False, None]

    @BridgeService.RegisterCallback
    def get_properties(session: int, args: list[any]):
        if isinstance(args[0], Instance):
            properties = []

            for Descriptor in args[0].ClassDescriptor.PropertyDescriptors.GetAllList():  # We filter in init script
                properties.append(Descriptor.Name)

            return [properties]

    @BridgeService.RegisterCallback
    def getbytecode(args: list[any]):
        # TODO: implement bytecode decompressor
        succeed = False
        script_bytecode: bytes = None

        if isinstance(args[0], Instance) and args[0].ClassName in base_script:
            script_bytecode = args[0].Bytecode
            succeed = True if script_bytecode is bytes else False
        else:
            return False

        return [succeed, (script_bytecode.hex() if succeed else None)]

    # @BridgeService.RegisterCallback
    # def custom_httpget(session: int, args: list[any]):
    #     succeed = False
    #     if isinstance(args[0], str):
    #         response = requests.get(args[0])

    #         if response.status_code == 200:
    #             succeed = True
    #             return [succeed, response.text]
    #         else:
    #             print(
    #                 f"Bridge error: status code of the website is {response.status_code} and cannot be reached"
    #             )

    @BridgeService.RegisterCallback
    def http_request(session: int, args: list[any]):
        options = args[0]
        if isinstance(options, dict):
            url = options.get("Url")

            if isinstance(url, str):
                def run_async(coro):
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(coro)
                    loop.close()
                    return result

                async def _http_request(options):
                    url = options.get("Url")
                    try:
                        async with aiohttp.ClientSession() as session:
                            async with session.request(
                                options.get("Method", "GET"),
                                url,
                                headers=options.get("Headers"),
                                cookies=options.get("Cookies"),
                                data=options.get("Body"),
                            ) as response:
                                response_data = {
                                    "Success": response.status == 200,
                                    "StatusCode": response.status,
                                    "StatusMessage": response.reason,
                                    "Headers": dict(response.headers),
                                    "Body": await response.text(),
                                }
                                return [True, response_data]
                    except Exception as e:
                        print(f"Http Request Error {e}")

                return run_async(_http_request(options))

    @BridgeService.RegisterCallback
    def get_custom_asset(session: int, args: list[any]):
        if isinstance(args[0], str):
            roblox_path_process = None

            file_path = path_no_escape(args[0])
            file_name = re.split(r"\\", args[0])[-1]

            for pid in psutil.pids():
                if psutil.Process(pid).name() == "RobloxPlayerBeta.exe":
                    roblox_path_process = psutil.Process(pid).exe()

            content_dir = os.path.join(os.path.dirname(roblox_path_process), "content", "catl_assets")

            if not os.path.exists(content_dir):
                os.makedirs(content_dir, exist_ok=True)

            dest_path = os.path.join(content_dir, file_name)
            if os.path.exists(dest_path):
                print(f"Bridge warning: file {file_name} already exists in the content directory")

            shutil.copy(file_path, dest_path)
            return [True, "rbxasset://" + file_name]

    @BridgeService.RegisterCallback
    def messagebox(session: int, args: list[any]):
        if (
            isinstance(args[0], str)
            and isinstance(args[1], str)
            and isinstance(args[2], int)
        ):
            result = user32.MessageBoxW(
                Window, args[0], args[1], args[2]
            )  # so it shows in roblox window
            return [True, result]

    # filesystem funcs
    @BridgeService.RegisterCallback
    def read_file(session: int, args: list[any]):
        f_path = path_no_escape(args[0])
        succeed, file_content = False, ""

        try:
            with open(f_path, "rb") as file:
                file_content = file.read().decode(encoding="ascii", errors="ignore")
                file.close()

            succeed = True
        except Exception as e:
            print(f"Bridge error: failed to read file '{f_path}'", e)

        return [succeed, file_content]

    @BridgeService.RegisterCallback
    def write_file(session: int, args: list[any]):
        f_path = path_no_escape(args[0])
        succeed, file_content = False, args[1]

        if isinstance(file_content, str):
            try:
                with open(f_path, "wb") as file:
                    file.write(file_content.encode(encoding="ascii", errors="ignore"))
                    file.close()

                succeed = True
            except Exception as e:
                print(f"Bridge error: failed to write file on '{f_path}'", e)

        return [succeed]

    @BridgeService.RegisterCallback
    def delete_dir(session: int, args: list[any]):
        f_path = path_no_escape(args[0])
        succeed = False

        try:
            if os.path.isfile(f_path):
                os.remove(f_path)

            elif os.path.isdir(f_path):
                shutil.rmtree(f_path)

            succeed = True
        except Exception as e:
            print(f"Bridge error: failed to delete path of '{f_path}'", e)

        return [succeed]

    @BridgeService.RegisterCallback
    def get_path_type(session: int, args: list[any]):
        f_path = path_no_escape(args[0])
        succeed, path_type = False, None

        try:
            if os.path.isfile(f_path):
                path_type = "file"

            elif os.path.isdir(f_path):
                path_type = "folder"

            succeed = True
        except Exception as e:
            print(f"Bridge error: failed to get path type of '{f_path}'", e)

        return [succeed, path_type]

    @BridgeService.RegisterCallback
    def list_files(session: int, args: list[any]):
        f_path = path_no_escape(args[0])
        succeed, paths = False, []

        if os.path.isdir(f_path):
            for current_path in os.listdir(f_path):
                paths.append(current_path.split("workspace\\")[-1])

            succeed = True

        return [succeed, (paths if succeed else None)]
    

    @BridgeService.RegisterCallback
    def make_folder(session: int, args: list[any]):
        f_path = path_no_escape(args[0])
        succeed = False

        try:
            if not os.path.isdir(f_path):
                os.mkdir(f_path)

            succeed = True
        except Exception as e:
            print(f"Bridge error: failed to make folder in '{f_path}'", e)

        return [succeed]
