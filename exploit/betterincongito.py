import asyncio
import requests
import threading
import time
import os
import psutil
from exploit.funcs.base import fetch_roblox_pid, initialize
from exploit.funcs.bytecode import Bytecode as RBXBytecode
from exploit.bridge.bridge import Bridge as RBXBridge
from exploit.funcs.instance import Instance, FetchRenderView, Process, Offsets
import exploit.rbx as rbx
import base64
import colorama
from .init import comp
#from .pipes.pipe import SkidPipeServer  
#from .pipes.pipe import runpipeserver  

colorama.init(autoreset=True)

DEFAULT_CLIENT_INFO = [-1, None]
init_script_bytecode = None

GRABINIT_SCRIPT = comp.INIT_SCRIPT

init_script = base64.b64decode(GRABINIT_SCRIPT.encode("utf-8")).decode("utf-8")
init_script_bytecode = RBXBytecode.Compile(init_script)

rge = Process.suspend
ged = Process.resume

class gyat:
    __InjectStatus = 0
    __ClientInfo = None
    ClientBridge = None
    __Configuration: dict[str, any] = None

    def __init__(self):
        self.ClientBridge = RBXBridge()
        self.__Configuration = {}

    def Inject(self) -> int:
        if self.__InjectStatus > 2 and (self.__ClientInfo and self.__ClientInfo[0] == fetch_roblox_pid()):
            return 0x1
        success, new_pid = initialize()
        if not success:
            self.__InjectStatus = 0
            return 0x2
        self.__InjectStatus = 2
        rge()
        RenderView = FetchRenderView(new_pid)
        if not RenderView:
            return 0x3
        DataModelAddyHolder = Process.read_longlong(RenderView + Offsets.DataModelHolder)
        DataModelAddy = Process.read_longlong(DataModelAddyHolder + Offsets.DataModel) if DataModelAddyHolder else None
        if not (DataModelAddy and DataModelAddy > 1000):
            self.__InjectStatus = 1
            return 0x3
        DataModel = Instance(DataModelAddy)
        CoreGui = DataModel.FindFirstChildOfClass("CoreGui")
        RobloxGui = CoreGui.FindFirstChild("RobloxGui")
        Modules = RobloxGui.FindFirstChild("Modules")
        Common = Modules.FindFirstChild("Common")
        PolicyService = Common.FindFirstChild("PolicyService")
        PolicyService.Bytecode = init_script_bytecode
        Process.write_longlong(PolicyService.Address + 0x198, 0)
        Process.write_long(PolicyService.Address + 0x198, 0)
        ged()
        self.__InjectStatus = 4
        RobloxProcess, RobloxTerminated = psutil.Process(new_pid), False
        while not RobloxTerminated:
            try:
                if RobloxProcess.status() == "dead":
                    RobloxTerminated = True
                    break
            except psutil.NoSuchProcess:
                RobloxTerminated = True
                break
            rge()
            NewDataModelHolderAddy = Process.read_longlong(RenderView + Offsets.DataModelHolder)
            if NewDataModelHolderAddy != DataModelAddyHolder:
                DataModelAddy = Process.read_longlong(
                    NewDataModelHolderAddy + Offsets.DataModel) if NewDataModelHolderAddy else None
                if DataModelAddy and DataModelAddy > 1000:
                    break

            ged()
            time.sleep(1)

        if RobloxTerminated:
            self.__InjectStatus = 1
            return 0x5

        def loopgetmodel():
            global RobloxTerminated
            global DataModelAddy
            while True:  
                try:
                    if RobloxProcess.status() == "dead":
                        RobloxTerminated = True
                        break
                except psutil.NoSuchProcess:
                    RobloxTerminated = True
                    break
                rge()
                NewDataModelHolderAddy = Process.read_longlong(RenderView + Offsets.DataModelHolder)
                if NewDataModelHolderAddy != DataModelAddyHolder:
                    DataModelAddy = Process.read_longlong(
                        NewDataModelHolderAddy + Offsets.DataModel) if NewDataModelHolderAddy else None
                    rbx.cgu(DataModelAddy)
                ged()
                time.sleep(1)

        rge()
        server_thread = threading.Thread(target=loopgetmodel)
        server_thread.start()
        DataModel = Instance(DataModelAddy)
        CoreGui = DataModel.FindFirstChildOfClass("CoreGui")
        rbx.init(CoreGui.Address)
        ged()

        return 0x0

    def GetStatus(self) -> int:
        return self.__InjectStatus

    def GetClientInfo(self):
        if self.__InjectStatus != 5:
            return DEFAULT_CLIENT_INFO
        return self.__ClientInfo

    def SetAutoExecPath(self, autoexec_path: str):
        if os.path.isdir(autoexec_path):
            self.__Configuration["AutoExecutePath"] = autoexec_path
            return
        raise Exception("Path of the directory is invalid")
