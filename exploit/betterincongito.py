import requests
import threading
import time
import os
import psutil
from exploit.funcs.base import fetch_roblox_pid, initialize
from exploit.funcs.bytecode import Bytecode as RBXBytecode
from exploit.bridge.bridge import Bridge as RBXBridge
from exploit.funcs.instance import Instance, FetchRenderView, Process, Offsets
import exploit.rbx as rbx

DEFAULT_CLIENT_INFO = [-1, None]
init_script_bytecode = None

# for debuging
LOCAL_SCRIPT_PATH = "env.luau"

def fetch_script_from_file(filepath: str) -> str:
    try:
        with open(filepath, 'r') as file:
            return file.read().strip()
    except IOError as e:
        print(f"Error loading init script from file: {e}")
        return "print'hello world'"

init_script = fetch_script_from_file(LOCAL_SCRIPT_PATH)
init_script_bytecode = RBXBytecode.Compile(init_script)

rge = Process.suspend
ged = Process.resume

# inject part rahhhh
class gyat:
    __InjectStatus = 0
    __ClientInfo = None
    ClientBridge = None
    __Configuration: dict[str, any] = None

    def __init__(self):
        self.ClientBridge = RBXBridge()
        self.__Configuration = {}

    def Inject(self) -> int:
        if self.__InjectStatus > 2 and (self.__ClientInfo and self.__ClientInfo[0] == fetch_roblox_pid()):
            return 0x1
        success, new_pid = initialize()
        if not success:
            self.__InjectStatus = 0
            return 0x2
        self.__InjectStatus = 2
        rge()
        RenderView = FetchRenderView(new_pid)
        if not RenderView:
            return 0x3
        DataModelAddyHolder = Process.read_longlong(RenderView + Offsets.DataModelHolder)
        DataModelAddy = Process.read_longlong(DataModelAddyHolder + Offsets.DataModel) if DataModelAddyHolder else None
        if not (DataModelAddy and DataModelAddy > 1000):
            self.__InjectStatus = 1
            return 0x3
        DataModel = Instance(DataModelAddy)
        CoreGui = DataModel.FindFirstChildOfClass("CoreGui")
        RobloxGui = CoreGui.FindFirstChild("RobloxGui")
        Modules = RobloxGui.FindFirstChild("Modules")
        Common = Modules.FindFirstChild("Common")
        PolicyService = Common.FindFirstChild("PolicyService")
        PolicyService.Bytecode = init_script_bytecode
        Process.write_longlong(PolicyService.Address + 0x198, 0)
        Process.write_long(PolicyService.Address + 0x198, 0)
        ged()
        self.__InjectStatus = 4
        RobloxProcess, RobloxTerminated = psutil.Process(new_pid), False
        while not RobloxTerminated:
            try:
                if RobloxProcess.status() == "dead":
                    RobloxTerminated = True
                    break
            except psutil.NoSuchProcess:
                RobloxTerminated = True
                break
            rge()
            NewDataModelHolderAddy = Process.read_longlong(RenderView + Offsets.DataModelHolder)
            if NewDataModelHolderAddy != DataModelAddyHolder:
                DataModelAddy = Process.read_longlong(
                    NewDataModelHolderAddy + Offsets.DataModel) if NewDataModelHolderAddy else None
                if DataModelAddy and DataModelAddy > 1000:
                    break

            ged()
            time.sleep(1)

        if RobloxTerminated:
            self.__InjectStatus = 1
            return 0x5

        def loopgetmodel():
            global RobloxTerminated
            global DataModelAddy
            while True:  # fetching new datamodel
                try:
                    if RobloxProcess.status() == "dead":
                        RobloxTerminated = True
                        break
                except psutil.NoSuchProcess:
                    RobloxTerminated = True
                    break
                rge()
                NewDataModelHolderAddy = Process.read_longlong(RenderView + Offsets.DataModelHolder)
                if NewDataModelHolderAddy != DataModelAddyHolder:
                    DataModelAddy = Process.read_longlong(
                        NewDataModelHolderAddy + Offsets.DataModel) if NewDataModelHolderAddy else None
                    rbx.cgu(DataModelAddy)
                ged()
                time.sleep(1)

        rge()
        server_thread = threading.Thread(target=loopgetmodel)
        server_thread.start()
        DataModel = Instance(DataModelAddy)
        CoreGui = DataModel.FindFirstChildOfClass("CoreGui")
        rbx.init(CoreGui.Address)
        ged()
        return 0x0

    def GetStatus(self) -> int:
        return self.__InjectStatus

    def GetClientInfo(self):
        if self.__InjectStatus != 5:
            return DEFAULT_CLIENT_INFO
        return self.__ClientInfo

    def SetAutoExecPath(self, autoexec_path: str):
        if os.path.isdir(autoexec_path):
            self.__Configuration["AutoExecutePath"] = autoexec_path
            return
        raise Exception("Path of the directory is invalid")
